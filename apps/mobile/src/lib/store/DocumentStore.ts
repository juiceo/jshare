import { InteractionManager } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { debounce, get, sortBy, type DebouncedFunc } from 'lodash';
import { makeAutoObservable, reaction, runInAction } from 'mobx';
import { computedFn } from 'mobx-utils';
import { z } from 'zod';

import { Document } from '~/lib/store/Document';
import { IndexedMap } from '~/lib/store/IndexedMap';
import { SystemStore } from '~/lib/store/SystemStore';
import type {
    CreateEntry,
    DeleteEntry,
    DocumentApi,
    DocumentFunctions,
    DocumentResolvers,
    DocumentStoreHooks,
    FindManyOpts,
    InferCreateInput,
    InferUpdateInput,
    Query,
    QueryEntry,
    QueryResultsArray,
    SyncResult,
    UpdateEntry,
} from '~/lib/store/types';
import { getAutoGeneratedProps, withRetry, type AutoGeneratedProps } from '~/lib/store/util';
import { getUserId } from '~/state/auth';

type DocumentStoreArgs<
    /**
     * The parser that defines the type of each document
     */
    S extends Zod.ZodSchema<{ id: string }>,
    /**
     * The API methods for the collection
     */
    A extends DocumentApi<T, any, any>,
    /**
     * The type of resolvers for each document
     */
    R extends DocumentResolvers<T>,
    /**
     * The type of the functions available for each document
     */
    F extends DocumentFunctions<T>,
    /**
     * The type of the indexed keys for each document
     */
    I extends (keyof T)[],
    /**
     * Helper type to infer the type of the document from the parser
     */
    T extends z.infer<S> = z.infer<S>,
> = {
    /**
     * A unique name for the collection
     */
    name: string;
    /**
     * A zod schema that defines the type of the data in the collection
     */
    schema: S;
    /**
     * The API methods for the collection
     */
    api: A;
    /**
     * A function that creates an optimistic document from create input and auto-generated properties.
     *
     * - If provided, all created documents will be immediately inserted to the store and show up in query results, before the server has created them.
     * - If not provided, created documents will be inserted to the store only after the server has created them and returned the created data.
     */
    createOptimistic?: (data: InferCreateInput<A> & AutoGeneratedProps) => T;
    /**
     * A function that creates an optimistic document from update input and auto-generated properties.
     *
     * - If provided, all updated documents will be immediately updated in the store and show up in query results, before the server has updated them.
     * - If not provided, updated documents will be updated in the store only after the server has updated them and returned the updated data.
     */
    updateOptimistic?: (data: T, updates: InferUpdateInput<A>) => T;
    /**
     * A map of resolvers for each document
     *
     * These can be used to derive additional properties from the document data - a good use case is for example resolving relations to other documents.
     */
    resolvers?: R;
    /**
     * A map of functions for each document
     *
     * These can be used to define actions that can be performed on each document.
     */
    functions?: F;
    /**
     * The indexed keys for the collection. Increases the performance of the store when querying by these keys, but
     * increases the memory usage and write duration of the store. Use with similar caution as database indexes.
     */
    indexedKeys?: I;
    /**
     * The mode for the collection
     *
     * - sync: continuously fetch data from the server in the background. The API returns all updated, added and removed documents since the last sync.
     * - on-demand: fetch data from the server only when the data is needed. The API returns the documents that match the provided query.
     */
    mode: 'on-demand' | 'sync';
    /**
     * A map of hooks for the collection
     */
    hooks?: DocumentStoreHooks<T>;
    /**
     * The stale time for the collection, after which the data is considered stale and will be refetched
     *
     * @default 60_000 (1 minute)
     */
    staleTime?: number;
};

export class DocumentStore<
    S extends Zod.ZodSchema<{ id: string }>,
    A extends DocumentApi<T, any, any>,
    R extends DocumentResolvers<T>,
    F extends DocumentFunctions<T>,
    I extends (keyof T)[],
    T extends z.infer<S> = z.infer<S>,
> {
    name: string;
    api: A;
    sync: (force?: boolean) => Promise<void>;
    flushUpdates: DebouncedFunc<() => Promise<T[]>>;
    flushQueries: DebouncedFunc<() => Promise<void>>;
    flushCreates: () => Promise<void>;
    flushDeletes: () => Promise<void>;
    updates: Record<string, UpdateEntry<A>> = {};
    queries: Record<string, QueryEntry<T>> = {};
    creates: Record<string, CreateEntry<A>> = {};
    deletes: Record<string, DeleteEntry<T>> = {};

    lastSync: SyncResult<T> | null = null;
    isSyncing: boolean = false;
    index: IndexedMap<DocumentStore<S, A, R, F, I, T>>;
    resolvers?: R;
    functions?: F;
    hooks?: DocumentStoreHooks<T>;
    staleTime: number;
    schema: S;
    createOptimistic?: (input: InferCreateInput<A> & AutoGeneratedProps) => T;
    updateOptimistic?: (data: T, updates: InferUpdateInput<A>) => T;
    mode: 'on-demand' | 'sync';
    isReady: boolean = false;
    init: () => Promise<void>;

    constructor(args: DocumentStoreArgs<S, A, R, F, I, T>) {
        this.index = new IndexedMap((args.indexedKeys || []) as I);
        makeAutoObservable(this, {
            findById: false,
            findMany: false,
        });
        this.name = args.name;
        this.api = args.api;
        this.resolvers = args.resolvers;
        this.functions = args.functions;
        this.staleTime = args.staleTime ?? 5000;
        this.hooks = args.hooks;
        this.schema = args.schema;
        this.createOptimistic = args.createOptimistic;
        this.updateOptimistic = args.updateOptimistic;
        this.mode = args.mode;

        this.sync = async (force?: boolean) => {
            if (!this.isReady) return;
            if (this.mode !== 'sync') return;
            if (!force) {
                if (this.isSyncing) return;
                if (this.lastSync) {
                    const now = Date.now();
                    if (now - this.lastSync.timestamp < this.staleTime) {
                        return;
                    }
                }
            }

            if (!this.api.sync) {
                console.warn(
                    `Tried to sync ${this.name}, but there is no sync method defined in the collection API.`
                );
                return;
            }

            runInAction(() => {
                this.isSyncing = true;
            });

            try {
                const result = await this.api.sync({ lastSync: this.lastSync?.timestamp ?? 0 });

                runInAction(() => {
                    this.lastSync = result;
                    this.isSyncing = false;

                    for (const item of result.created) {
                        this.registerItem(item);
                    }

                    for (const item of result.updated) {
                        this.registerItem(item);
                    }

                    for (const id of result.removed) {
                        this.disposeItem(id);
                    }
                });
            } catch (error) {
                runInAction(() => {
                    setTimeout(() => {
                        this.isSyncing = false;
                    }, 1000);
                });
                console.error('sync error', this.name, error);
            }
        };

        this.flushQueries = debounce(
            async () => {
                if (!this.isReady) return;
                const queriesToRun = runInAction(() => {
                    return Object.entries(this.queries).filter(([key, item]) => {
                        if (item.status === 'pending') {
                            this.queries[key].status = 'running';
                            return true;
                        }
                        return false;
                    });
                });

                if (queriesToRun.length === 0) {
                    return;
                }

                const ids = queriesToRun
                    .map(([key, item]) => {
                        if (item.type === 'findById') {
                            return item.id;
                        }
                        return null;
                    })
                    .filter((id) => id !== null);

                const queries = queriesToRun
                    .map(([key, item]) => {
                        if (item.type === 'findMany') {
                            return item.query;
                        }
                        return null;
                    })
                    .filter((where) => where !== null);

                const { added, removed } = await Promise.all([
                    ids.length > 0 && this.api.findById
                        ? this.api.findById({ ids }).then((res) => {
                              return {
                                  added: res,
                                  removed: ids.filter((id) => !res.some((r) => r.id === id)),
                              };
                          })
                        : Promise.resolve({ added: [], removed: [] }),
                    queries.length > 0 && this.api.findMany
                        ? this.api.findMany({ queries }).then((res) => {
                              const queriesWithResults = queries.map((query, index) => {
                                  return {
                                      query,
                                      results: res[index],
                                  };
                              });

                              return queriesWithResults.reduce(
                                  (acc, { query, results }) => {
                                      const currentResults = this.index.find(query);

                                      for (const result of results) {
                                          acc.added.push(result);
                                      }

                                      for (const current of currentResults) {
                                          if (!results.some((r) => r.id === current.id)) {
                                              acc.removed.push(current.id);
                                          }
                                      }

                                      return acc;
                                  },
                                  { added: [] as T[], removed: [] as string[] }
                              );
                          })
                        : Promise.resolve({ added: [], removed: [] }),
                ]).then((res) => {
                    return {
                        added: res.flatMap((r) => r.added),
                        removed: res.flatMap((r) => r.removed),
                    };
                });

                runInAction(() => {
                    for (const id of removed) {
                        this.disposeItem(id);
                    }
                    for (const doc of added) {
                        this.registerItem(doc);
                    }

                    /**
                     * TODO: Handle errors somehow (mark query state as failed?)
                     */
                    queriesToRun.forEach(([key]) => {
                        if (this.queries[key].status === 'running') {
                            this.queries[key].status = 'done';
                            this.queries[key].lastFetched = Date.now();
                        }
                    });
                });
            },
            10,
            { maxWait: 100 }
        );

        this.flushUpdates = debounce(
            async () => {
                if (!this.isReady) return [];
                if (!SystemStore.isConnected) return [];
                if (!this.api.update) {
                    console.warn(
                        `Tried to flush updates in ${this.name}, but there is no update method defined in the collection API.`
                    );
                    return [];
                }
                const updatesToRun = runInAction(() => {
                    return Object.entries(this.updates).filter(([id, data]) => {
                        if (data.status === 'pending') {
                            this.updates[id].status = 'running';
                            return true;
                        }
                        return false;
                    });
                });
                if (updatesToRun.length === 0) return [];

                return Promise.all(
                    updatesToRun.map(async ([id, data]) =>
                        withRetry(() => this.api.update!({ id, data: data.updates }))
                            .then((res) => {
                                runInAction(() => {
                                    delete this.updates[id];
                                });
                                return res;
                            })
                            .catch((err: Error) => {
                                if ('data' in err) {
                                    const status = get(err, 'data.httpStatus');
                                    if (status && status >= 400 && status < 500) {
                                        runInAction(() => {
                                            delete this.updates[id];
                                        });
                                        return null;
                                    }
                                } else {
                                    runInAction(() => {
                                        if (this.updates[id]) {
                                            this.updates[id].status = 'pending';
                                        }
                                    });
                                }
                            })
                    )
                )
                    .then((results) => {
                        return results.filter((r) => r !== undefined && r !== null);
                    })
                    .then((docs) => {
                        if (this.hooks?.afterUpdate) {
                            docs.forEach((data) => {
                                this.hooks!.afterUpdate!(data);
                            });
                        }
                        return docs;
                    });
            },
            1000,
            { maxWait: 15_000 }
        );

        this.flushCreates = async () => {
            if (!this.isReady) return;
            if (!SystemStore.isConnected) return;
            if (!this.api.create) {
                console.warn(
                    `Tried to flush creates in ${this.name}, but there is no create method defined in the collection API.`
                );
                return;
            }
            const createsToRun = runInAction(() => {
                return Object.values(this.creates).filter((entry) => {
                    if (entry.status === 'pending') {
                        this.creates[entry.id].status = 'running';
                        return true;
                    }
                    return false;
                });
            });

            if (createsToRun.length === 0) return;
            const sortedCreates = sortBy(createsToRun, (entry) => entry.data.createdAt);

            for (const entry of sortedCreates) {
                await withRetry(() => this.api.create!({ id: entry.id, data: entry.data }))
                    .then((res) => {
                        runInAction(() => {
                            delete this.creates[entry.id];
                            this.registerItem(res);
                        });
                        return res;
                    })
                    .catch((err) => {
                        if ('data' in err) {
                            const status = get(err, 'data.httpStatus');
                            if (status && status >= 400 && status < 500) {
                                runInAction(() => {
                                    delete this.creates[entry.id];
                                    this.disposeItem(entry.id);
                                });
                                return null;
                            }
                        } else {
                            runInAction(() => {
                                if (this.creates[entry.id]) {
                                    this.creates[entry.id].status = 'pending';
                                }
                            });
                            return null;
                        }
                    })
                    .then((createdData) => {
                        if (createdData && this.hooks?.afterCreate) {
                            this.hooks!.afterCreate!(createdData);
                        }
                    });
            }
        };

        this.flushDeletes = async () => {
            if (!this.isReady) return;
            if (!SystemStore.isConnected) return;
            const deletesToRun = runInAction(() => {
                return Object.values(this.deletes).filter((entry) => {
                    if (entry.status === 'pending') {
                        this.deletes[entry.id].status = 'running';
                        return true;
                    }
                    return false;
                });
            });

            if (deletesToRun.length === 0) return;

            await Promise.all(
                deletesToRun.map(async (entry) => {
                    return this.api
                        .delete?.({ id: entry.id })
                        .then(() => {
                            runInAction(() => {
                                delete this.deletes[entry.id];
                            });
                        })
                        .catch((err: Error) => {
                            if ('data' in err) {
                                const status = get(err, 'data.httpStatus');
                                if (status && status >= 400 && status < 500) {
                                    runInAction(() => {
                                        delete this.creates[entry.id];
                                    });
                                    return null;
                                }
                            } else {
                                runInAction(() => {
                                    if (this.creates[entry.id]) {
                                        this.creates[entry.id].status = 'failed';
                                    }
                                    this.registerItem(entry.data);
                                });
                                return null;
                            }
                        });
                })
            );
        };

        const flushAllMutations = async () => {
            await this.flushCreates();
            await this.flushUpdates();
            await this.flushDeletes();
        };

        if (this.mode === 'sync') {
            setInterval(() => {
                this.sync();
            }, 1000);
        }

        reaction(
            () => SystemStore.isConnected,
            async () => {
                if (SystemStore.isConnected) {
                    await flushAllMutations();
                    this.sync(true);
                }
            }
        );

        reaction(
            () => this.index.updatedAt,
            () => {
                this.persist();
            },
            {
                delay: 2500,
            }
        );

        this.init = async () => {
            if (!this.isReady) {
                await this.hydrate();
                this.isReady = true;
            }
            flushAllMutations();
            this.sync(true);
        };
    }

    private async hydrate() {
        const items = await AsyncStorage.getItem(`DocumentStore::${this.name}`);
        const parsedItems = items ? JSON.parse(items) : [];
        console.log('HYDRATING', this.name, parsedItems.length);
        const docs = parsedItems
            .map((item: any) => {
                if (!item) return null;
                try {
                    const parsed = this.schema.parse(item);
                    return new Document<DocumentStore<S, A, R, F, I, T>>(
                        this,
                        parsed as T,
                        this.resolvers
                    );
                } catch (error) {
                    console.error('Error parsing persisted document');
                    console.error(error);
                    return null;
                }
            })
            .filter((d: any) => d !== null);
        runInAction(() => {
            this.index.init(docs);
        });
    }

    private async persist() {
        InteractionManager.runAfterInteractions(async () => {
            const items = this.index.getAll().map((doc) => doc.snapshot);
            await AsyncStorage.setItem(`DocumentStore::${this.name}`, JSON.stringify(items));
        });
    }

    private async clearPersistedState() {
        await AsyncStorage.removeItem(`DocumentStore::${this.name}`);
    }

    private getQueryKey(queryOrId: string | Query<T>) {
        return typeof queryOrId === 'string' ? queryOrId : JSON.stringify(queryOrId);
    }

    private isQueryStale(queryKey: string) {
        const query = this.queries[queryKey];
        if (!query) return true;
        if (query.status === 'running') return false;
        if (!query.lastFetched) return true;
        return Date.now() - query.lastFetched > this.staleTime;
    }

    invalidate() {
        switch (this.mode) {
            case 'on-demand': {
                runInAction(() => {
                    this.queries = {};
                });
                break;
            }
            case 'sync': {
                this.lastSync = null;
                this.sync(true);
                break;
            }
        }
    }

    invalidateQuery(queryOrId: string | Query<T>) {
        if (typeof queryOrId === 'string') {
            this.registerFindById(queryOrId, true);
        } else {
            this.registerQuery(queryOrId, true);
        }
    }

    isLoading = computedFn(() => {
        switch (this.mode) {
            case 'on-demand': {
                return Object.values(this.queries).some((q) => q.status !== 'done');
            }
            case 'sync': {
                return this.isSyncing;
            }
        }
    });

    getQueryState = computedFn((queryKey: string | undefined) => {
        if (!queryKey) return null;
        return this.queries[queryKey]?.status;
    });

    private async registerFindById(id: string, forceInvalidate = false) {
        let shouldFlush = forceInvalidate;
        runInAction(() => {
            if (!this.queries[id]) {
                this.queries[id] = {
                    type: 'findById',
                    id,
                    lastFetched: null,
                    status: 'pending',
                };
                shouldFlush = true;
            } else if (this.isQueryStale(id) || forceInvalidate) {
                this.queries[id].status = 'pending';
                shouldFlush = true;
            }
        });

        if (shouldFlush) {
            return this.flushQueries();
        }
    }

    private async registerQuery(query: Query<T>, forceInvalidate = false) {
        let shouldFlush = false;
        runInAction(() => {
            const key = this.getQueryKey(query);
            if (!this.queries[key]) {
                this.queries[key] = {
                    type: 'findMany',
                    query,
                    lastFetched: null,
                    status: 'pending',
                };
                shouldFlush = true;
            } else if (this.isQueryStale(key) || forceInvalidate) {
                this.queries[key].status = 'pending';
                shouldFlush = true;
            }
        });

        if (shouldFlush) {
            return this.flushQueries();
        }
    }

    private findByIdComputed = computedFn((id: string) => {
        return this.index.get(id);
    });

    findById(id: string | null | undefined) {
        if (!id) return null;
        switch (this.mode) {
            case 'on-demand': {
                if (!this.api.findById) {
                    console.warn(
                        `Tried to call findById in ${this.name}, but there is no findById method defined in the collection API. This query will likely return an empty result.`
                    );
                }
                this.registerFindById(id);
                break;
            }
            case 'sync': {
                this.sync();
                break;
            }
        }
        return this.findByIdComputed(id);
    }

    private findByIdsComputed = computedFn((ids: string[]) => {
        return ids.map((id) => this.index.get(id)).filter((doc) => doc !== undefined);
    });

    findByIds(ids: string[]) {
        if (ids.length === 0) return [];
        switch (this.mode) {
            case 'on-demand': {
                if (!this.api.findById) {
                    console.warn(
                        `Tried to call findByIds in ${this.name}, but there is no findById method defined in the collection API. This query will likely return an empty result.`
                    );
                }
                ids.forEach((id) => {
                    this.registerFindById(id);
                });
                break;
            }
            case 'sync': {
                this.sync();
                break;
            }
        }
        return this.findByIdsComputed(ids);
    }

    private findManyComputed = computedFn(
        (args: string): QueryResultsArray<DocumentStore<S, A, R, F, I, T>> => {
            const { where, opts } = JSON.parse(args) as {
                where: Query<T>;
                opts?: FindManyOpts<T>;
            };

            let docs = this.index.find(where);

            const { orderBy, limit } = opts || {};
            if (orderBy) {
                docs = sortBy(docs, (doc) => (doc.data as T)[orderBy.field]);
                if (orderBy.order === 'desc') {
                    docs = docs.reverse();
                }
            }
            if (limit) {
                docs = docs.slice(0, limit);
            }

            const queryKey = this.getQueryKey(where);

            return Object.defineProperties([...docs], {
                $queryKey: {
                    value: queryKey,
                    enumerable: false,
                },
                $loading: {
                    get: () => this.queries[queryKey]?.status !== 'done',
                    enumerable: false,
                },
            }) as QueryResultsArray<DocumentStore<S, A, R, F, I, T>>;
        }
    );

    findMany(where: Query<T>, opts?: FindManyOpts<T>) {
        switch (this.mode) {
            case 'on-demand': {
                if (!this.api.findMany) {
                    console.warn(
                        `Tried to call findMany in ${this.name}, but there is no findMany method defined in the collection API. This query will likely return an empty result.`
                    );
                }
                this.registerQuery(where);
                break;
            }
            case 'sync': {
                this.sync();
                break;
            }
        }
        return this.findManyComputed(JSON.stringify({ where, opts }));
    }

    registerItem(
        item: z.infer<S>,
        opts?: { optimistic: true }
    ): Document<DocumentStore<S, A, R, F, I, T>> {
        if (this.index.has(item.id)) {
            this.index.update(item.id, item);
            const doc = this.index.get(item.id)!;
            doc.setOptimistic(opts?.optimistic ?? false);
            return this.index.get(item.id)!;
        } else {
            const doc = new Document<DocumentStore<S, A, R, F, I, T>>(this, item, this.resolvers);
            doc.setOptimistic(opts?.optimistic ?? false);
            this.index.add(item.id, doc);
            return doc;
        }
    }

    disposeItem(id: string) {
        this.index.delete(id);
    }

    async create(input: InferCreateInput<A>) {
        if (!this.api.create) {
            throw new Error(
                `Tried to create a document in ${this.name}, but there is no create method defined in the collection API.`
            );
        }
        const userId = getUserId();
        if (!userId) return null;

        const autoGenerated = getAutoGeneratedProps();

        const data = {
            ...autoGenerated,
            ...input,
        };

        this.creates[data.id] = {
            id: data.id,
            data,
            status: 'pending',
        };

        if (this.createOptimistic) {
            const optimisticData = this.createOptimistic(data);
            this.registerItem(optimisticData, { optimistic: true });
        }

        return this.flushCreates();
    }

    async update(id: string, updates: InferUpdateInput<A>) {
        if (!this.api.update) {
            console.warn(
                `Tried to update a document in ${this.name}, but there is no update method defined in the collection API.`
            );
            return;
        }
        const doc = this.index.get(id);
        if (!doc) return;

        this.updates[id] = {
            id,
            updates: {
                ...this.updates[id]?.updates,
                ...updates,
            },
            status: 'pending',
        };

        if (this.updateOptimistic) {
            const optimisticData = this.updateOptimistic(doc.data as T, { ...updates });
            this.registerItem(optimisticData, { optimistic: true });
        }

        this.flushUpdates();
    }

    delete(id: string) {
        if (!this.api.delete) {
            console.warn(
                `Tried to delete a document in ${this.name}, but there is no delete method defined in the collection API.`
            );
            return;
        }
        const doc = this.index.get(id);
        if (!doc) return;
        this.disposeItem(id);

        this.deletes[id] = {
            id,
            data: doc.snapshot as T,
            status: 'pending',
        };
        delete this.updates[id];
        delete this.creates[id];

        this.flushDeletes();
    }

    async reset() {
        runInAction(() => {
            this.queries = {};
            this.updates = {};
            this.deletes = {};
            this.creates = {};
            this.index.clear();
            this.isReady = false;
        });
        return this.clearPersistedState();
    }
}
